# Story 2.5: Database Schema for Users & Readings Association

## Status

**Approved**

---

## Story

**As a** developer,  
**I want** user readings properly associated with user accounts,  
**so that** we can retrieve user-specific reading history efficiently.

---

## Acceptance Criteria

1. `users` table schema: `id` (UUID from Supabase Auth), `email`, `name`, `profile_picture_url`, `created_at`, `last_login_at`
2. `readings` table updated: `user_id` (foreign key to users, nullable for anonymous)
3. Database migration created and applied to add user_id column to existing readings
4. Prisma schema updated with User model and relationships
5. Row Level Security (RLS) policies: users can only read/write their own data
6. Index created on `readings.user_id` for fast queries
7. Cascade delete rule: if user deleted, associated readings also deleted (or anonymized)
8. Anonymous readings: readings created before login have `user_id = NULL`
9. Reading claiming: when anonymous user signs up, option to claim previous readings (bonus feature)
10. Database queries tested: fetch user readings, create reading with user_id, update user profile

---

## Tasks / Subtasks

- [ ] **Task 1: Create Users Table** (AC: 1)
  - [ ] Add User model to `prisma/schema.prisma`:

    ```prisma
    model User {
      id                  String    @id @db.Uuid
      email               String    @unique @db.VarChar(255)
      name                String?   @db.VarChar(100)
      profile_picture_url String?   @db.Text
      created_at          DateTime  @default(now()) @db.Timestamptz
      updated_at          DateTime  @updatedAt @db.Timestamptz
      last_login_at       DateTime? @db.Timestamptz
      email_verified      Boolean   @default(false)
      auth_provider       AuthProvider @default(email)

      readings            Reading[]
      favorite_cards      FavoriteCard[]
      preferences         UserPreferences?

      @@map("users")
      @@index([email])
      @@index([created_at])
    }

    enum AuthProvider {
      email
      google
      facebook
    }
    ```

  - [ ] Note: `id` comes from Supabase Auth, not auto-generated

- [ ] **Task 2: Update Readings Table** (AC: 2)
  - [ ] Add `user_id` column to Reading model:
    ```prisma
    model Reading {
      id            String      @id @default(uuid()) @db.Uuid
      user_id       String?     @db.Uuid  // NEW: nullable for anonymous
      reading_type  ReadingType
      question      String?     @db.VarChar(500)
      created_at    DateTime    @default(now()) @db.Timestamptz
      updated_at    DateTime    @updatedAt @db.Timestamptz
      is_favorite   Boolean     @default(false)
      notes         String?     @db.VarChar(2000)

      user          User?        @relation(fields: [user_id], references: [id], onDelete: Cascade)
      reading_cards ReadingCard[]

      @@map("readings")
      @@index([user_id])
      @@index([created_at(sort: Desc)])
      @@index([user_id, created_at(sort: Desc)])
      @@index([reading_type])
    }
    ```
  - [ ] Foreign key to users table
  - [ ] Cascade delete if user deleted

- [ ] **Task 3: Create Database Migration** (AC: 3)
  - [ ] Run Prisma migration:
    ```bash
    pnpm prisma migrate dev --name add_users_table
    ```
  - [ ] Migration will:
    - Create `users` table
    - Add `user_id` column to `readings` table
    - Add foreign key constraint
    - Create indexes
  - [ ] Verify migration files created in `prisma/migrations/`
  - [ ] Apply migration to database
  - [ ] Verify in Supabase dashboard

- [ ] **Task 4: Update Prisma Client** (AC: 4)
  - [ ] Regenerate Prisma Client:
    ```bash
    pnpm prisma generate
    ```
  - [ ] Update TypeScript types
  - [ ] Verify type checking passes: `pnpm type-check`
  - [ ] Test queries with new schema

- [ ] **Task 5: Implement Row Level Security (RLS)** (AC: 5)
  - [ ] Enable RLS on `users` table:
    ```sql
    ALTER TABLE users ENABLE ROW LEVEL SECURITY;
    ```
  - [ ] Create RLS policy for users:

    ```sql
    -- Users can view their own profile
    CREATE POLICY "Users can view own profile"
    ON users FOR SELECT
    USING (auth.uid() = id);

    -- Users can update their own profile
    CREATE POLICY "Users can update own profile"
    ON users FOR UPDATE
    USING (auth.uid() = id);
    ```

  - [ ] Update readings RLS policies:

    ```sql
    -- Users can view their own readings
    CREATE POLICY "Users can view own readings"
    ON readings FOR SELECT
    USING (auth.uid() = user_id);

    -- Users can create readings
    CREATE POLICY "Users can create readings"
    ON readings FOR INSERT
    WITH CHECK (auth.uid() = user_id OR user_id IS NULL);

    -- Users can update their own readings
    CREATE POLICY "Users can update own readings"
    ON readings FOR UPDATE
    USING (auth.uid() = user_id);

    -- Users can delete their own readings
    CREATE POLICY "Users can delete own readings"
    ON readings FOR DELETE
    USING (auth.uid() = user_id);

    -- Anonymous readings viewable by anyone with ID
    CREATE POLICY "Anonymous readings viewable"
    ON readings FOR SELECT
    USING (user_id IS NULL);
    ```

  - [ ] Test RLS policies work

- [ ] **Task 6: Create Database Indexes** (AC: 6)
  - [ ] Indexes already defined in Prisma schema:
    - `readings.user_id` (for user history queries)
    - `readings.created_at DESC` (for chronological order)
    - `(user_id, created_at) DESC` (composite for user history)
  - [ ] Verify indexes created by migration
  - [ ] Test query performance with EXPLAIN

- [ ] **Task 7: Configure Cascade Delete** (AC: 7)
  - [ ] Option 1: Cascade delete (delete readings when user deleted)
    ```prisma
    user User? @relation(fields: [user_id], references: [id], onDelete: Cascade)
    ```
  - [ ] Option 2: Anonymize (set user_id to NULL)
    ```prisma
    user User? @relation(fields: [user_id], references: [id], onDelete: SetNull)
    ```
  - [ ] Choose based on product requirements (recommend Cascade for GDPR)
  - [ ] Test: delete user → verify readings deleted/anonymized

- [ ] **Task 8: Handle Anonymous Readings** (AC: 8)
  - [ ] When creating reading without auth:
    ```typescript
    const reading = await prisma.reading.create({
      data: {
        reading_type: 'daily',
        user_id: null, // Anonymous
        // ... other fields
      },
    });
    ```
  - [ ] Anonymous readings have `user_id = NULL`
  - [ ] Can still be accessed via reading ID
  - [ ] Update API routes to handle both auth and anonymous

- [ ] **Task 9: Reading Claiming Feature (Bonus)** (AC: 9)
  - [ ] Store session ID in anonymous readings:
    ```prisma
    model Reading {
      // ... existing fields
      session_id String? @db.VarChar(255)  // Track anonymous sessions
    }
    ```
  - [ ] When user signs up, check for readings with matching session:
    ```typescript
    const claimReadings = async (userId: string, sessionId: string) => {
      await prisma.reading.updateMany({
        where: {
          user_id: null,
          session_id: sessionId,
        },
        data: {
          user_id: userId,
        },
      });
    };
    ```
  - [ ] Show success message: "3 readings added to your history!"
  - [ ] This is optional/bonus feature

- [ ] **Task 10: Create User on Auth** (AC: 1)
  - [ ] Create database trigger or application logic:
    ```typescript
    // After successful signup (in auth callback)
    const createUserRecord = async (authUser: AuthUser) => {
      await prisma.user.create({
        data: {
          id: authUser.id, // From Supabase Auth
          email: authUser.email,
          name: authUser.user_metadata?.name || null,
          profile_picture_url: authUser.user_metadata?.avatar_url || null,
          email_verified: authUser.email_confirmed_at !== null,
          auth_provider: authUser.app_metadata?.provider || 'email',
        },
      });
    };
    ```
  - [ ] Call after successful signup
  - [ ] Handle OAuth (Google, Facebook) metadata

- [ ] **Task 11: Update API Routes** (AC: 10)
  - [ ] Update POST /api/readings to accept user_id:
    ```typescript
    export async function POST(request: NextRequest) {
      const user = await validateAuth(request, { required: false });
      const { reading_type, question, cards } = await request.json();

      const reading = await prisma.reading.create({
        data: {
          reading_type,
          question,
          user_id: user?.id || null, // NULL if anonymous
          reading_cards: {
            create: cards.map((card: DrawnCard) => ({
              card_id: card.cardId,
              position: card.position,
              is_reversed: card.isReversed,
            })),
          },
        },
      });

      return NextResponse.json({ reading });
    }
    ```

- [ ] **Task 12: Create User Queries** (AC: 10)
  - [ ] Fetch user readings:
    ```typescript
    const getUserReadings = async (userId: string, limit = 20, offset = 0) => {
      return await prisma.reading.findMany({
        where: { user_id: userId },
        include: {
          reading_cards: {
            include: { card: true },
            orderBy: { position: 'asc' },
          },
        },
        orderBy: { created_at: 'desc' },
        take: limit,
        skip: offset,
      });
    };
    ```
  - [ ] Update user profile:
    ```typescript
    const updateUserProfile = async (userId: string, data: UpdateUserData) => {
      return await prisma.user.update({
        where: { id: userId },
        data: {
          name: data.name,
          profile_picture_url: data.profilePictureUrl,
          updated_at: new Date(),
        },
      });
    };
    ```

- [ ] **Task 13: Testing Database Queries** (AC: 10)
  - [ ] Test queries:

    ```typescript
    // Create user
    test('create user record', async () => {
      const user = await prisma.user.create({
        data: {
          id: 'test-uuid',
          email: 'test@example.com',
          name: 'Test User',
        },
      });
      expect(user.id).toBe('test-uuid');
    });

    // Create reading with user_id
    test('create reading for user', async () => {
      const reading = await prisma.reading.create({
        data: {
          user_id: 'test-uuid',
          reading_type: 'daily',
        },
      });
      expect(reading.user_id).toBe('test-uuid');
    });

    // Fetch user readings
    test('fetch user readings', async () => {
      const readings = await prisma.reading.findMany({
        where: { user_id: 'test-uuid' },
      });
      expect(readings.length).toBeGreaterThan(0);
    });

    // Test cascade delete
    test('delete user cascades to readings', async () => {
      await prisma.user.delete({ where: { id: 'test-uuid' } });
      const readings = await prisma.reading.findMany({
        where: { user_id: 'test-uuid' },
      });
      expect(readings.length).toBe(0);
    });
    ```

  - [ ] Test RLS policies (use Supabase client)
  - [ ] Test anonymous readings

- [ ] **Task 14: Data Migration for Existing Readings** (AC: 3)
  - [ ] If database has existing anonymous readings:
    - They keep `user_id = NULL` (valid state)
    - No data migration needed
  - [ ] If backfilling needed:
    - Create script to assign readings to users based on session data
    - Run carefully with backups

- [ ] **Task 15: Documentation** (AC: 1-10)
  - [ ] Document database schema changes
  - [ ] Document RLS policies
  - [ ] Document query patterns
  - [ ] Document reading claiming feature
  - [ ] Add ER diagram (optional)
  - [ ] Commit: "feat: Add users table and user-readings association"

---

## Dev Notes

### Previous Story Insights

**From Story 1.2 (Database Setup):**

- Prisma configured
- Readings table exists
- Migration workflow established

**From Story 2.1-2.4 (Auth Stories):**

- User authentication working
- User data structure defined
- Profile page needs user table

**Integration Points:**

- User ID links readings to accounts
- RLS enforces data privacy
- Reading history queries use user_id
- Profile page displays user data

---

### Database Schema Diagram

```
┌─────────────────────┐         ┌─────────────────────┐
│      users          │         │     readings        │
├─────────────────────┤         ├─────────────────────┤
│ id (PK, UUID)       │←────────│ user_id (FK, NULL)  │
│ email (UNIQUE)      │   1:N   │ id (PK)             │
│ name                │         │ reading_type        │
│ profile_picture_url │         │ question            │
│ created_at          │         │ created_at          │
│ last_login_at       │         │ ...                 │
│ ...                 │         └─────────────────────┘
└─────────────────────┘                   │
                                          │ 1:N
                                          ↓
                              ┌─────────────────────┐
                              │   reading_cards     │
                              ├─────────────────────┤
                              │ id (PK)             │
                              │ reading_id (FK)     │
                              │ card_id (FK)        │
                              │ position            │
                              │ is_reversed         │
                              └─────────────────────┘
```

---

### Row Level Security (RLS)

**Why RLS?**

- Database-level security (not just application)
- Prevents data leaks even if API has bugs
- Enforced for all queries (direct or via API)
- Required for Supabase best practices

**RLS Policies Summary:**

- Users can only see their own profile
- Users can only see their own readings
- Anonymous readings (`user_id = NULL`) visible to anyone with ID
- All write operations check user ownership

[Source: architecture/database-schema.md]

---

### Prisma Schema Complete

```prisma
// prisma/schema.prisma

// Users table (NEW)
model User {
  id                  String    @id @db.Uuid
  email               String    @unique @db.VarChar(255)
  name                String?   @db.VarChar(100)
  profile_picture_url String?   @db.Text
  created_at          DateTime  @default(now()) @db.Timestamptz
  updated_at          DateTime  @updatedAt @db.Timestamptz
  last_login_at       DateTime? @db.Timestamptz
  email_verified      Boolean   @default(false)
  auth_provider       AuthProvider @default(email)

  readings            Reading[]
  favorite_cards      FavoriteCard[]
  preferences         UserPreferences?

  @@map("users")
  @@index([email])
  @@index([created_at])
}

enum AuthProvider {
  email
  google
  facebook
}

// Readings table (UPDATED)
model Reading {
  id            String      @id @default(uuid()) @db.Uuid
  user_id       String?     @db.Uuid  // ADDED
  reading_type  ReadingType
  question      String?     @db.VarChar(500)
  created_at    DateTime    @default(now()) @db.Timestamptz
  updated_at    DateTime    @updatedAt @db.Timestamptz
  is_favorite   Boolean     @default(false)
  notes         String?     @db.VarChar(2000)

  user          User?        @relation(fields: [user_id], references: [id], onDelete: Cascade)  // ADDED
  reading_cards ReadingCard[]

  @@map("readings")
  @@index([user_id])  // ADDED
  @@index([created_at(sort: Desc)])
  @@index([user_id, created_at(sort: Desc)])  // ADDED
  @@index([reading_type])
}
```

[Source: architecture/database-schema.md]

---

### Testing Strategy

**Unit Tests:**

- Prisma query functions
- User creation logic
- Reading claiming logic

**Integration Tests:**

- Database migrations
- RLS policy enforcement
- Cascade deletes
- Foreign key constraints

**SQL Tests:**

```sql
-- Test RLS: try to access other user's reading
SET request.jwt.claims = '{"sub":"user1-uuid"}';
SELECT * FROM readings WHERE user_id = 'user2-uuid';
-- Should return 0 rows (blocked by RLS)

-- Test cascade delete
DELETE FROM users WHERE id = 'test-uuid';
SELECT COUNT(*) FROM readings WHERE user_id = 'test-uuid';
-- Should return 0 (readings deleted)
```

**Coverage Target:**

- Database queries: 100%
- RLS policies: 100% (critical for security)

[Source: architecture/testing-strategy.md]

---

### Notes

**Important:**

- User ID comes from Supabase Auth (not auto-generated)
- Nullable user_id supports anonymous readings
- RLS is critical for data security
- Cascade delete ensures GDPR compliance

**Dependencies:**

- **Story 1.2 completed**: Prisma and database setup
- **Story 2.1 completed**: Supabase Auth configured
- No blockers

**Blockers:**

- None

**Future Considerations:**

- Soft delete (mark as deleted, don't remove data)
- Data export for GDPR compliance
- Multi-tenancy (if needed)
- Read replicas for scaling

---

## Change Log

| Date       | Version | Description            | Author           |
| ---------- | ------- | ---------------------- | ---------------- |
| 2026-01-01 | 1.0     | Initial story creation | Sarah (PO Agent) |

---

## Dev Agent Record

_This section will be populated by the development agent during implementation._

---

## QA Results

_This section will be populated by the QA Agent after story completion._
